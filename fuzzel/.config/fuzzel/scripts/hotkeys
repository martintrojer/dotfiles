#!/usr/bin/env python3
"""Show Niri keybindings in a fuzzel picker."""

from __future__ import annotations

import argparse
import os
import re
import shlex
from pathlib import Path

from _common import ScriptError, fuzzel_dmenu, notify, picker_cache_path, require_commands, run


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--config",
        default=f"{os.environ.get('XDG_CONFIG_HOME', str(Path.home() / '.config'))}/niri/config.kdl",
        help="Path to niri config.kdl",
    )
    parser.add_argument("--prompt", default="Hotkeys  ")
    parser.add_argument("--width", type=int, default=80)
    parser.add_argument("--lines", type=int, default=20)
    parser.add_argument("--key-width", type=int, default=24)
    return parser.parse_args()


def parse_bind_entries(config_path: Path, key_width: int) -> list[tuple[str, str]]:
    content = config_path.read_text(encoding="utf-8")
    lines = content.splitlines()

    in_binds = False
    entries: list[tuple[str, str]] = []
    title_re = re.compile(r'hotkey-overlay-title="([^"]+)"')

    for raw in lines:
        line = raw.strip()
        if not in_binds:
            if re.match(r"^binds\s*\{", line):
                in_binds = True
            continue

        if line == "}":
            break
        if not line or line.startswith("//"):
            continue
        if "{" not in line or "}" not in line:
            continue

        key = line.split()[0]
        title_match = title_re.search(line)
        title = title_match.group(1) if title_match else ""

        action_match = re.search(r"\{([^}]+)\}", line)
        action = ""
        if action_match:
            action = action_match.group(1).strip().removesuffix(";").strip()

        label = title or action
        if label:
            entries.append((f"{key:<{key_width}} {label}", action))

    return entries


def execute_action(action: str) -> None:
    if not action:
        return

    parts = shlex.split(action)
    if not parts:
        return

    verb = parts[0]

    if verb == "spawn-sh" and len(parts) >= 2:
        run(["sh", "-lc", parts[1]], check=False)
        return

    if verb == "spawn" and len(parts) >= 2:
        run(parts[1:], check=False)
        return

    run(["niri", "msg", "action", *parts], check=False)


def main() -> int:
    args = parse_args()
    config_path = Path(args.config).expanduser()
    require_commands(["fuzzel", "niri"])

    if not config_path.exists():
        notify("Hotkeys", f"Niri config not found: {config_path}")
        raise ScriptError(f"Niri config not found: {config_path}")

    entries = parse_bind_entries(config_path, args.key_width)
    if not entries:
        notify("Hotkeys", f"No keybindings found in {config_path}")
        raise ScriptError("No keybindings found")

    cache = picker_cache_path("hotkeys")
    display = [item[0] for item in entries]
    selected = fuzzel_dmenu(prompt=args.prompt, width=args.width, lines=args.lines, cache=cache, options=display)
    if not selected:
        return 0

    chosen = next((item for item in entries if item[0] == selected), None)
    if chosen is None:
        return 0

    execute_action(chosen[1])
    return 0


if __name__ == "__main__":
    try:
        raise SystemExit(main())
    except ScriptError as exc:
        print(f"hotkeys: {exc}")
        raise SystemExit(1)
